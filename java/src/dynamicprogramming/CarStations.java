package dynamicprogramming;

/**
 * 汽车装配线调度问题
 * 一个汽车工厂，有汽车生产装配线2条，编号为i(0,1)，每条装配线有n个装配站，编号为j(0~n-1)。
 * 一个工件进入装配线i的时间为e[i]，完成后离开装配线i的时间为x[i]。
 * 每个工件在装配线i的装配站j装配的时间为a[i][j]。
 * 同一个装配线上时，工件从上一个装配站到下一个装配站不需要时间。
 * 工厂允许工件在不同的装配线上装配，
 * 从装配线i的装配站j完成后移走到另一条装配线上需要时间为t[i][j]。
 * 如果有个加急订单，如何用最快的方式加工完成？
 */
public class CarStations {

    /**
     * 使用动态规划求解问题
     * 1. 最优解的结构
     * 考虑到有两种情况完成加工：1. 从装配线0完成加工； 2. 从装配线1完成加工。
     * 那么对于更一般的情况，通过装配站S[0][j]的最快路线无非是以下两种情况：
     * a. 以最快路径通过装配站S[0][j-1]，然后直接通过装配站S[i][j]
     * b. 以最快路径通过装配站S[1][j-1]，然后从装配线1移动到装配线0，并通过装配站S[i][j]
     * 那么到达装配站S[1][j]的最快路径则是类似的。
     * <p>
     * 2. 递归定义最优解
     * 设到达装配站S[i][j]的最快路径所花的时间为这时可以得到最优解的递推公式：
     * f = min(f[0][n-1] + x[0], f[1][n-1] + x[1])
     * 当j=0时（通过第一个装配站）：
     * f[0][0] = e[0] + a[0][0];
     * f[1][0] = e[1] + a[1][0];
     * 更一般的情况（装配线0）：
     * f[0][j] = e[0] + a[0][0]; (j == 0)
     * f[0][j] = min(f[0][j-1] + a[0][j], f[0][j-1] + t[0][j-1] + a[0][j]); (j > 0)
     * 对于装配线1则是类似的。
     * <p>
     * 3. 自底向上计算最优解的值
     * 4. 根据计算结果构造最优解
     * <p>
     * 时间复杂度O(n)，空间复杂度O(n)
     *
     * @param e 进入装配线所需要的时间
     * @param x 全部装配完成后，离开装配线所需要的时间
     * @param a 在装配站S[i][j]装配所需要的时间
     * @param t 从装配线i的装配站j完成后移走到另一条装配线上所需要时间
     * @param n 每条装配线上装配站的数量
     * @return 工件加工完成的最快方式，[0～n-1]为依次加工的装配线编号，[n]为所需总时间
     */
    public int[] fastestAssembly(int[] e, int[] x, int[][] a, int[][] t, int n) {
        // 输入校验
        if (e == null || e.length != 2 || x == null || x.length != 2 ||
                a == null || a.length != 2 || a[0].length != n ||
                t == null || t.length != 2 || t[0].length != n - 1) {
            return null;
        }
        // 定义变量
        int[] result = new int[n + 1];
        // f为从装配站[i][j]完成的最快时间
        int[][] f = new int[2][n];
        // l为从装配站[i][j]完成的最快路径，上一次装配的装配线编号
        int[][] l = new int[2][n];
        f[0][0] = e[0] + a[0][0];
        f[1][0] = e[1] + a[1][0];
        int last;
        // 自底向上遍历计算从装配站[i][j]完成的最快时间，并记录上一次装配的装配线编号
        for (int j = 1; j < n; j++) {
            int from0 = f[0][j - 1] + a[0][j];
            int from1 = f[1][j - 1] + t[1][j - 1] + a[0][j];
            if (from0 < from1) {
                f[0][j] = from0;
                l[0][j] = 0;
            } else {
                f[0][j] = from1;
                l[0][j] = 1;
            }
            from1 = f[1][j - 1] + a[1][j];
            from0 = f[0][j - 1] + t[0][j - 1] + a[1][j];
            if (from1 < from0) {
                f[1][j] = from1;
                l[1][j] = 1;
            } else {
                f[1][j] = from0;
                l[1][j] = 0;
            }
        }
        if (f[0][n - 1] + x[0] < f[1][n - 1] + x[1]) {
            result[n] = f[0][n - 1] + x[0];
            last = 0;
        } else {
            result[n] = f[1][n - 1] + x[1];
            last = 1;
        }
        // 根据所记录的信息，得到每次装配的装配线编号，并得出最快时间
        for (int j = n - 1; j > 0; j--) {
            last = l[last][j];
            result[j - 1] = last;
        }
        return result;
    }
}
